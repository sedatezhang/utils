# Java基础面试题

## 1. 什么是Java？

Java是一种广泛使用的面向对象的编程语言，它具有跨平台、安全性高、性能较高等特点。Java程序先被编译成字节码，然后在Java虚拟机（JVM）上运行。

Java的主要特性包括：
- **跨平台性**：通过"一次编写，到处运行"的JVM实现
- **面向对象**：支持封装、继承、多态等面向对象特性
- **自动内存管理**：通过垃圾回收机制自动管理内存
- **安全性**：提供安全管理器和类加载器保障系统安全
- **多线程支持**：内置多线程功能，便于开发并发程序

## 2. Java有哪些基本数据类型？

Java有8种基本数据类型：
- `byte`：8位有符号整数，范围是-128到127
- `short`：16位有符号整数，范围是-32768到32767
- `int`：32位有符号整数，默认整数字面量类型
- `long`：64位有符号整数，需要在数字后加L或l
- `float`：32位浮点数，需要在数字后加F或f
- `double`：64位浮点数，默认浮点数字面量类型
- `char`：16位Unicode字符
- `boolean`：只有两个值true和false

> 注意：Java没有sizeof运算符，因为Java中各数据类型的大小是固定的，不随平台变化而变化。

## 3. 什么是面向对象编程？

面向对象编程（OOP）是一种编程范式，它将数据（属性）和操作数据的方法封装在一起，形成对象。OOP的三大特征是封装、继承和多态。

- **封装**：隐藏对象内部细节，仅暴露必要的接口
- **继承**：子类可以继承父类的属性和方法，实现代码复用
- **多态**：同一接口的不同实现方式，包括编译时多态（方法重载）和运行时多态（方法重写）

## 4. 什么是类和对象？

类是对象的蓝图或模板，它定义了对象的属性和方法。对象是类的具体实例。比如，"汽车"是一个类，而"一辆红色的宝马车"就是它的一个对象。

类包含以下要素：
- **字段（Fields）**：也称为成员变量，用于描述对象的状态
- **方法（Methods）**：描述对象的行为
- **构造函数（Constructor）**：用于初始化对象
- **代码块（Code Block）**：用于初始化的代码段
- **内部类（Inner Class）**：定义在另一个类内部的类

## 5. 什么是封装？

封装是OOP的第一个特性，它是将数据（变量）和行为（方法）包装在一个类中，并对外部隐藏实现细节。通过使用访问修饰符（private、protected、public）来控制访问级别。

封装的好处：
- 提高安全性：防止外部直接访问和修改对象状态
- 提高可维护性：内部实现可以自由修改而不影响外部调用
- 提高代码复用率：封装的功能模块可以被多个地方调用

## 6. 什么是继承？

继承是一个类（子类）可以继承另一个类（父类）的属性和方法。这实现了代码的重用，并建立了类之间的层次关系。

继承的特点：
- 子类继承父类的所有非私有成员（包括字段和方法）
- 子类可以添加自己的新字段和方法
- 子类可以重写父类的方法实现
- Java只支持单继承，一个类只能有一个直接父类

## 7. 什么是多态？

多态是指同一个接口可以用不同的方式实现。在Java中，多态主要体现在方法重写（运行时多态）和方法重载（编译时多态）。

多态的三个必要条件：
1. 继承
2. 方法重写
3. 父类引用指向子类对象

示例：
```java
Animal a = new Cat(); // 向上转型
a.speak(); // 调用的是Cat的speak方法
```

## 8. 什么是抽象类？

抽象类是不能实例化的类，只能作为其他类的基类。它可能包含抽象方法（没有实现的方法）也可能包含具体实现的方法。通过关键字abstract声明。

抽象类的特点：
- 包含抽象方法的类必须声明为抽象类
- 抽象类不能被实例化
- 抽象类可以包含抽象方法、具体方法、构造函数等
- 抽象类的子类要么实现所有抽象方法，要么也声明为抽象类

## 9. 什么是接口？

接口是抽象类型的集合，它定义了一组方法规范。一个类可以实现多个接口，从而实现多重继承的效果。从Java 8开始，接口可以包含默认方法实现。

接口的特点：
- 接口中的方法默认都是public abstract的
- 接口中的变量默认都是public static final的
- 类通过implements关键字实现接口
- 一个类可以实现多个接口
- 接口支持默认方法和静态方法（Java 8+）

## 10. 什么是构造函数？

构造函数是一种特殊的函数，用于初始化新创建的对象。它的名称与类名相同，没有返回类型，不能被显式调用，在创建对象时自动调用。

构造函数的特点：
- 构造函数与类同名且没有返回值类型
- 每个类至少有一个构造函数（如果没有显式定义，Java会提供一个默认构造函数）
- 构造函数可以重载
- 构造函数可以调用同类的其他构造函数（通过this()）
- 构造函数可以调用父类构造函数（通过super()）

## 11. 什么是方法重载？

方法重载是指在同一个类中，允许存在多个同名方法，但参数列表必须不同（参数个数不同、参数类型不同）。返回类型可以不同，但不能仅以此作为重载条件。

方法重载的特点：
- 方法名相同
- 参数列表不同（参数个数、参数类型、参数顺序）
- 返回类型可以不同
- 访问权限可以不同
- 抛出的异常可以不同

## 12. 什么是方法重写？

方法重写是指子类重新定义父类的方法。方法签名（名称、返回类型和参数列表）必须相同，访问权限不能比父类更严格。

方法重写的规则：
- 方法名、参数列表、返回类型必须与父类方法相同
- 访问权限不能比父类方法更严格
- 抛出的异常范围不能比父类方法更大
- 静态方法不能被重写
- 私有方法不能被重写

## 13. 什么是static关键字？

static关键字用来创建类级别的成员。静态变量和静态方法属于类而不是类的实例。可以直接通过类名调用，不需要创建对象。

static可以修饰：
- 变量（静态变量）
- 方法（静态方法）
- 代码块（静态代码块）
- 内部类（静态内部类）

静态成员的特点：
- 属于类而不是类的实例
- 在类加载时初始化
- 可以通过类名直接访问
- 静态方法不能访问非静态成员

## 14. 什么是final关键字？

final关键字可以用来修饰类、方法和变量：
- 修饰类：该类不能被继承
- 修饰方法：该方法不能被重写
- 修饰变量：该变量不能被修改，成为常量

final的特殊应用：
- final修饰的引用类型变量，其引用地址不能改变，但对象的内容可以改变
- final修饰的方法可以在编译时内联，提高效率
- final类中的所有方法都会被隐式地变为final

## 15. 什么是super关键字？

super关键字用于引用父类的成员。可以通过super调用父类的构造方法、访问父类的属性和方法。

super的使用场景：
- 当子类和父类有同名成员时，区分父类成员
- 显式调用父类的构造方法
- 调用被重写的父类方法

## 16. 什么是this关键字？

this关键字指代当前对象。可以用this调用本类的其他构造方法，也可以用来区分局部变量和成员变量。

this的使用场景：
- 区分同名的成员变量和局部变量
- 调用本类的构造方法
- 将当前对象作为参数传递给其他方法

## 17. 什么是字符串池？

字符串池是Java堆内存中的一个特殊区域，用来存储String对象。当创建一个字符串时，如果字符串池中已经存在该字符串，则直接返回已存在的引用，避免重复创建。

字符串池的优化：
- 编译期优化：对于字面量字符串，会在编译时就加入字符串池
- 运行时优化：通过String.intern()方法手动将字符串加入池
- 减少内存占用：相同的字符串共享存储

## 18. String、StringBuilder和StringBuffer有什么区别？

- String：不可变的字符串，每次修改都会创建新的对象
- StringBuilder：可变字符串，非线程安全，效率高
- StringBuffer：可变字符串，线程安全，效率相对低一些

选择建议：
- 单线程环境下优先使用StringBuilder
- 多线程共享访问时使用StringBuffer
- 频繁修改字符串时避免使用String
- 字符串拼接超过3次建议使用可变字符串类

## 19. 什么是异常？

异常是程序执行期间发生的错误或意外事件。Java中所有异常都继承自Throwable类，分为检查异常（checked exceptions）和非检查异常（unchecked exceptions）。

Java异常体系：
- Throwable
  - Error：严重问题，一般应用程序不应该捕获
  - Exception
    - RuntimeException：运行时异常，非检查异常
    - 其他Exception：检查异常

## 20. 什么是try-catch-finally？

- try：监控代码块，可能出现异常的代码放在这里
- catch：捕获并处理异常
- finally：无论是否发生异常都会执行的代码块，通常用于释放资源

使用注意事项：
- try块后面可以没有catch块，但必须有finally块
- 多个catch块时，异常类型范围小的应该放在前面
- try-with-resources语法（Java 7+）可以自动关闭资源
- finally块中的代码在try/catch块返回前执行

## 21. 什么是垃圾回收？

垃圾回收是Java自动管理内存的机制。当一个对象不再被任何引用指向时，垃圾回收器会自动回收该对象占用的内存。

垃圾回收算法：
- 引用计数法
- 标记-清除算法
- 标记-整理算法
- 分代收集算法（新生代：复制算法；老年代：标记-清除/标记-整理）

GC类型：
- Minor GC：发生在新生代的垃圾回收
- Full GC/Major GC：发生在老年代的垃圾回收

## 22. 什么是泛型？

泛型是Java的一种参数化机制，可以在定义类、接口和方法时使用类型参数。它提供了编译时类型安全检测，并且减少了类型转换的需要。

泛型的好处：
- 类型安全：在编译时而非运行时检测类型错误
- 消除类型转换：无需手动强制类型转换
- 代码复用：一套逻辑可以适用于多种数据类型
- 编译器优化：泛型擦除后生成的字节码更高效

## 23. 什么是集合框架？

集合框架是Java提供的一组接口和类，用于存储和操作一组对象。主要包含三大接口：List（有序集合）、Set（无序不重复集合）和Map（键值对集合）。

集合框架的核心接口：
- Collection
  - List：有序可重复
  - Set：无序不可重复
- Map：键值对映射

常用实现类：
- ArrayList：基于动态数组实现的List
- LinkedList：基于链表实现的List
- HashSet：基于哈希表实现的Set
- TreeSet：基于红黑树实现的有序Set
- HashMap：基于哈希表实现的Map
- TreeMap：基于红黑树实现的有序Map

## 24. List、Set和Map有什么区别？

- List：有序的，可以有重复元素，可以通过索引访问
- Set：无序的，不允许有重复元素
- Map：存储键值对，每个键最多映射一个值

遍历方式：
- List和Set可以通过Iterator迭代器或增强for循环遍历
- Map可以通过keySet()、entrySet()或values()获取集合视图进行遍历

线程安全：
- Vector和Hashtable是线程安全的集合类
- Collections工具类可以将集合包装成线程安全的版本
- Java 5引入了ConcurrentHashMap等线程安全的集合类

## 25. 什么是多线程？

多线程是指一个程序同时执行多个任务的能力。Java通过Thread类和Runnable接口支持多线程编程，可以充分利用CPU资源，提高程序性能。

线程状态：
- 新建（New）
- 就绪（Runnable）
- 运行（Running）
- 阻塞（Blocked）
- 等待（Waiting）
- 超时等待（Timed Waiting）
- 终止（Terminated）

线程调度：
- 抢占式调度：高优先级线程抢占低优先级线程
- 协作式调度：线程主动让出CPU
- Java采用抢占式调度

## 26. 如何创建线程？

有两种主要方式创建线程：
1. 继承Thread类并重写run()方法
2. 实现Runnable接口并实现run()方法

推荐使用Runnable接口的方式，因为：
- Java不支持多继承，如果类已经继承了其他类，就不能再继承Thread
- Runnable接口更容易共享资源
- 更符合面向对象的设计思想，分离了任务和执行者

Java 5新增了Callable接口和ExecutorService线程池来更高效地管理线程。

## 27. 什么是synchronized关键字？

synchronized关键字用于控制多线程对共享资源的访问，确保在同一时刻只有一个线程执行特定的代码块或方法。

synchronized的应用：
- 修饰实例方法：锁住当前实例对象（this）
- 修饰静态方法：锁住当前类的Class对象
- 修饰代码块：可以指定任意对象作为锁

同步机制：
- 使用监视器锁（Monitor Lock）实现
- 确保原子性、可见性和有序性
- 支持重入锁：同一个线程可以多次获得同一把锁

## 28. 什么是volatile关键字？

volatile关键字确保变量在多个线程间可见，当一个线程修改了volatile变量的值，其他线程可以立即看到这个改变。

volatile的作用：
- 保证可见性：修改后的值立即刷新回主内存
- 保证有序性：禁止指令重排序
- 不保证原子性：i++等复合操作仍需配合锁使用

volatile与synchronized的区别：
- volatile只能修饰变量，synchronized可以修饰方法和代码块
- volatile保证可见性和有序性，synchronized保证原子性、可见性和有序性
- volatile不会造成线程阻塞，synchronized可能导致线程阻塞

## 29. 什么是设计模式？

设计模式是在软件设计过程中反复出现的问题的解决方案。它不是最终的设计或代码，而是一种描述如何解决问题的模板。

设计模式的分类：
- 创建型模式：关注对象创建过程
- 结构型模式：关注对象和类的组合方式
- 行为型模式：关注对象间的交互和职责分配

设计模式的原则：
- 开闭原则：对扩展开放，对修改关闭
- 里氏替换原则：子类应该能替换掉它们的父类型
- 依赖倒置原则：要依赖于抽象，不要依赖于具体实现
- 接口隔离原则：客户端不应该依赖它们不需要的方法
- 单一职责原则：一个类应该只有一个引起它变化的原因

## 30. 常见的设计模式有哪些？

常见的设计模式包括：
- 单例模式：确保一个类只有一个实例
- 工厂模式：提供一个创建对象的接口，让子类决定实例化哪一个类
- 观察者模式：定义对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖者都会收到通知
- 适配器模式：使不兼容接口能够一起工作
- 策略模式：定义一系列算法，将它们封装并可以互换使用

扩展补充：

## 31. 什么是深拷贝和浅拷贝？

- 浅拷贝：创建一个新对象，对于引用类型字段只是复制了引用地址，而不是创建一个新的对象
- 深拷贝：创建一个新对象，对于引用类型字段会递归地进行拷贝，创建新的对象

实现方式：
- 浅拷贝：可以通过Object.clone()方法实现
- 深拷贝：可以通过序列化反序列化实现，或者递归复制每个引用类型字段

## 32. 什么是反射？

反射是Java提供的一个特性，它允许程序在运行时获取类的信息（如类名、方法、字段等），并且可以动态调用方法和访问字段。

反射的主要类：
- Class：表示类的类型信息
- Method：表示类的方法
- Field：表示类的字段
- Constructor：表示类的构造方法

反射的用途：
- 实现通用框架
- 动态代理
- 注解处理
- 测试工具

## 33. 什么是注解？

注解是Java的一种元数据形式，它可以添加到Java代码中，为代码提供额外的信息。这些信息可以在编译时或运行时被处理。

注解的基本类型：
- JDK内置注解：如@Override、@Deprecated、@SuppressWarnings等
- 自定义注解：通过@interface定义

注解的生命周期：
- SOURCE：仅保存在源代码中
- CLASS：保存在.class文件中，但不会加载到JVM
- RUNTIME：保存在.class文件中，并会加载到JVM，可以通过反射读取

## 34. 什么是lambda表达式？

lambda表达式是Java 8引入的一个新特性，它允许我们以更简洁的方式表示匿名函数。

lambda表达式的特点：
- 简洁的语法：参数 -> 表达式或代码块
- 函数式编程支持
- 可以访问外部变量，但要求变量是final的或不可变的
- 支持类型推断

使用场景：
- 简化匿名内部类
- 集合遍历和操作
- 并行计算

## 35. 什么是Stream API？

Stream API是Java 8引入的一个新的处理集合的新方式，它提供了类似SQL语句的流式操作，可以方便地对集合进行过滤、映射、排序等操作。

Stream的操作步骤：
1. 获取流
2. 中间操作（过滤、映射等）
3. 终止操作（产生结果）

常用操作：
- filter()：过滤元素
- map()：转换元素
- sorted()：排序
- collect()：收集结果
- forEach()：遍历元素
- limit()：限制元素数量

## 36. 什么是Optional类？

Optional类是Java 8引入的一个容器类，用于存放非空对象。它提供了一系列方法来优雅地处理对象为空的情况，避免空指针异常。

常用方法：
- of()：创建一个Optional对象，如果参数为null则抛出异常
- ofNullable()：创建一个Optional对象，允许参数为null
- isPresent()：判断值是否存在
- get()：获取值，如果值不存在会抛出异常
- orElse()：如果值不存在，返回默认值
- ifPresent()：如果值存在，执行特定操作

## 37. 什么是Java内存模型？

Java内存模型（JMM）定义了Java程序中各种变量（线程共享变量）的访问规则，以及在并发环境下如何处理变量的读写操作。

内存模型的主要特性：
- 原子性：确保操作不可中断
- 可见性：一个线程对共享变量的修改对其他线程可见
- 有序性：程序执行顺序按照代码顺序

内存划分：
- 程序计数器：记录当前线程执行的位置
- Java虚拟机栈：每个方法执行时创建的栈帧
- 本地方法栈：为Native方法服务
- Java堆：所有线程共享，存放对象实例
- 方法区：存储已被虚拟机加载的类信息、常量池、静态变量等

## 38. 什么是类加载机制？

类加载机制是Java运行时环境根据需要动态加载类的过程。类加载经历了加载、验证、准备、解析和初始化等阶段。

类加载的过程：
1. 加载：通过类的全限定名获取类的二进制字节流
2. 验证：确保Class文件的字节流符合当前虚拟机的要求
3. 准备：为类变量分配内存并设置初始值
4. 解析：将常量池内的符号引用替换为直接引用
5. 初始化：执行类构造器<clinit>方法

类加载器：
- 启动类加载器（Bootstrap ClassLoader）
- 扩展类加载器（Extension ClassLoader）
- 应用程序类加载器（Application ClassLoader）
- 自定义类加载器

## 39. 什么是双亲委派模型？

双亲委派模型是Java类加载器的一种组织结构，它要求除了顶层的启动类加载器外，所有的类加载器都有自己的父类加载器。

工作原理：
1. 类加载器收到类加载请求
2. 首先委托给父类加载器去加载
3. 逐层向上委托
4. 如果父类加载器无法完成加载，才由自己尝试加载

优点：
- 避免重复加载
- 安全可靠：防止核心类库被篡改
- 结构清晰：类加载器呈树状结构

## 40. 什么是序列化和反序列化？

序列化是将对象转换为字节序列的过程，反序列化是将字节序列恢复为对象的过程。

应用场景：
- 对象持久化存储
- 网络传输
- 远程方法调用（RMI）

实现方式：
- 实现Serializable接口（标记接口）
- 实现Externalizable接口（更灵活但需要手动实现序列化逻辑）
- 使用transient关键字排除不想序列化的字段

注意事项：
- 序列化ID serialVersionUID 的作用
- 版本一致性问题
- 安全性问题：反序列化可能带来安全隐患

## 41. 什么是Java NIO？

Java NIO（New IO）是从Java 1.4引入的一套新的IO API，可以替代传统的IO API。NIO支持面向缓冲区的、基于通道的IO操作。

核心组件：
- Buffer：缓冲区，用于存储数据
- Channel：通道，用于读写数据
- Selector：选择器，用于监听多个通道的事件

优势特点：
- 非阻塞IO：一个线程可以处理多个连接
- 高效的数据传输：通过内存映射文件提高效率
- 选择器机制：实现单线程管理多个通道

## 42. 什么是Java中的四种引用？

Java中有四种引用强度依次减弱的引用类型：
- 强引用（StrongReference）：最常用的引用类型，即使内存不足也不会被回收
- 软引用（SoftReference）：内存不足时会被回收，适合实现缓存
- 弱引用（WeakReference）：下次GC时一定会被回收
- 虚引用（PhantomReference）：任何时候都可能被回收，主要用于跟踪对象被垃圾回收的状态

## 43. 什么是Java中的线程池？

线程池是一组预先创建的线程，它们等待任务分配。使用线程池可以减少线程创建和销毁的开销，提高系统的响应速度和资源利用率。

线程池的优点：
- 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁的开销
- 提高响应速度：任务到达时无需等待线程创建就能立即执行
- 提高线程的可管理性：可以统一管理线程，避免大量线程因互相争夺资源导致的系统瘫痪

Java中的线程池：
- FixedThreadPool：固定大小的线程池
- CachedThreadPool：可根据需要自动创建新线程的线程池
- SingleThreadExecutor：单线程的线程池
- ScheduledThreadPool：支持定时和周期性任务执行的线程池

## 44. 什么是Java中的Future？

Future代表一个异步计算的结果。它提供了检查计算是否完成、取消计算、获取计算结果等方法。

Future的主要方法：
- cancel()：尝试取消任务的执行
- isCancelled()：判断任务是否被取消
- isDone()：判断任务是否完成
- get()：获取任务执行结果，如果任务未完成会阻塞等待
- get(timeout, unit)：在指定时间内等待任务完成并获取结果

局限性：
- 无法手动设置任务结果
- 无法对多个任务进行链式调用
- 无法将多个任务的结果进行组合

Java 8引入了CompletableFuture来解决这些问题。

## 45. 什么是Java中的CompletableFuture？

CompletableFuture是Java 8引入的用于简化异步编程的API，它提供了更强大的功能来处理异步任务和结果。

主要特点：
- 支持异步任务执行
- 支持任务链式调用
- 支持多个任务的组合和依赖
- 支持异常处理
- 支持手动完成任务

常用方法：
- supplyAsync()：异步执行有返回值的任务
- runAsync()：异步执行无返回值的任务
- thenApply()：对结果进行变换
- thenAccept()：消费结果
- thenRun()：运行后续任务
- thenCombine()：组合两个任务的结果
- exceptionally()：异常处理

## 46. 什么是Java中的函数式编程？

函数式编程是一种编程范式，它强调使用纯函数和不可变数据。Java 8引入了函数式编程特性，如lambda表达式和函数式接口。

核心概念：
- 函数是一等公民：可以作为参数传递，可以作为返回值，可以赋值给变量
- 纯函数：输入相同输出一定相同，没有副作用
- 不可变数据：避免共享状态带来的并发问题

Java中的函数式接口：
- Consumer：消费型接口，接收参数无返回值
- Supplier：供给型接口，无参数有返回值
- Function：函数型接口，有参数有返回值
- Predicate：断言型接口，接收参数返回布尔值

## 47. 什么是Java中的模块系统？

Java 9引入了模块系统（JPMS），它通过模块（module）来封装包，提高了系统的可维护性和可管理性。

模块的优势：
- 更强的封装性：明确哪些包是导出的，哪些是内部的
- 明确的依赖关系：模块声明明确的依赖
- 更快的启动时间：按需加载模块
- 更小的运行时：可以根据需要裁剪模块

模块的声明：
- 使用module-info.java文件定义模块
- 使用requires关键字声明依赖
- 使用exports关键字声明导出的包
- 使用provides...with声明服务实现

## 48. 什么是Java中的文本块？

文本块是Java 13引入的一个预览特性，它允许使用多行字符串，使得处理JSON、SQL等格式更加方便。

文本块的特点：
- 使用三个双引号"""作为起始和结束分隔符
- 自动处理换行符
- 支持字符串插值（Java 15+）
- 支持缩进处理

示例：
```java
String sql = """
        SELECT id, name, email
        FROM users
        WHERE age > 18
        ORDER BY name
        """;
```

## 49. 什么是Java中的模式匹配？

模式匹配是Java 16引入的一个特性，它允许在instanceof检查后自动进行类型转换。

传统写法：
```java
if (obj instanceof String) {
    String s = (String) obj;
    System.out.println(s.length());
}
```

模式匹配写法：
```java
if (obj instanceof String s) {
    System.out.println(s.length());
}
```

优势：
- 减少冗余的类型转换代码
- 提高代码可读性
- 减少类型转换错误

## 50. 什么是Java中的记录类（Record）？

记录类是Java 16引入的一个新特性，它提供了一种简洁的方式来声明不可变的数据载体类。

传统POJO类：
```java
public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() { return x; }
    public int getY() { return y; }

    @Override
    public String toString() { ... }

    @Override
    public boolean equals(Object o) { ... }

    @Override
    public int hashCode() { ... }
}
```

记录类写法：
```java
public record Point(int x, int y) {}
```

特点：
- 默认生成构造方法、getter方法、toString()、equals()和hashCode()
- 不可变：字段都是final的
- 不能继承其他类，也不能被继承
- 适合用于数据传输对象（DTO）、值对象等场景